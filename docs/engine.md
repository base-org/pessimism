# Risk Engine

## Overview
The Risk Engine is responsible for handling and executing active invariants. It is the primary downstream consumer of ETL output. The Risk Engine will receive data from the ETL and execute the invariants associated with the data. If an invalidation occurs, the Risk Engine will return an `InvalidationOutcome` to the `EngineManager`. The `EngineManager` will then create an `Alert` using the `InvalidationOutcome` and publish it to the Alerting system.

The Risk Engine will execute the invariants associated with some ingested input data and return an `InvalidationOutcome` to the `EngineManager`. The `EngineManager` will then create an `Alert` using the `InvalidationOutcome` and publish it to the Alerting system.

The following diagram further exemplifies this key interaction:
```mermaid
graph LR;
    subgraph A["Engine Manager"]
        C(eventLoop) -.->  C;
        C --> |input|D("execute()")
        D --> |input.PUUID|E[SessionStore]
        E --> |"[]sessions"|D
        D --> |"[]sessions"|F[Risk Engine]
        F --> |"[]outcome"|D
        D --> |"[]alert"|G[Alerting Relay]
    end

    subgraph AA["ETL Manager"]
        Z["engineRelay"] --> |"invariant input"|C
    end

    subgraph AAA["Alerting Manager"]
        G --> FF("eventLoop()")
    end
```

## Inter-Connectivity
The ETL publishes `Invariant Input` to the Risk Engine using a relay channel. The Risk Engine will subscribe to this channel to receive and process updates as they are published by the ETL. The Risk Engine will also publish events to the Alerting system using a separate downstream relay channel. The Alerting system will subscribe to this channel to receive and process updates as they are published by the Risk Engine.

## Invariant Session
An invariant session refers the the execution and representation of a single invariant. An invariant session is uniquely identified by a `SUUID` and is associated with a single `PUUID`. An invariant session is created by the `EngineManager` when a user requests to run an active session. The `EngineManager` will create a new `InvariantSession` and pass it to the `RiskEngine` to be executed. The `RiskEngine` will then execute the invariant session and return an `InvalidationOutcome` to the `EngineManager`. The `EngineManager` will then create an `Alert` using the `InvalidationOutcome` and publish it to the Alerting system.

## Session UUID (SUUID)
The SUUID is a unique identifier that is used to identify a specific invariant session. The SUUID is generated by the `EngineManager` when a user requests to run a new invariant session. The SUUID is used to uniquely identify a specific invariant session. This allows the `EngineManager` to perform operations on a specific invariant session such as removing it or updating it. 

A `SUUID` constitutes of both a unique `UUID` and a `PID`. 

A `SessionPID` is encoded using the following 3 byte array sequence:
```
            0           1           2           3
            |-----------|-----------|-----------|
               network    pipeline    invariant
                type        type        type
```

## Invariant Input
The invariant input is a struct that contains the following fields:
* `PUUID` - The ID of the invariant that the input data is intended for
* `Input` - Transit data that was generated by the ETL

## Invariant
An invariant is a logical execution module that defines some set of invalidation criteria. The invariant is responsible for processing the input data and determining if an invalidation has occured. If an invalidation has occured, the invariant will return a `InvalidationOutcome` that contains relevant metadata necessary for the `EngineManager` to create an `Alert`.

### Hardcoded Base Invariant
Every hardcoded invariant must implement an `Invariant` interface to be compatible for invalidation by the `Hardcoded` Risk Engine type. Currently the interface is as follows:
```
type Invariant interface {
	Addressing() bool
	InputType() core.RegisterType
	Invalidate(core.TransitData) (*core.InvalOutcome, bool, error)
	SUUID() core.InvSessionUUID
	SetSUUID(core.InvSessionUUID)
}

``` 

### Invariant Input Type
The invariant input type is a `RegisterType` that defines the type of data that the invariant will receive as input. The invariant input type is defined by the `InputType()` method of the `Invariant` interface. The invariant input type is used by the `RiskEngine` to determine if the input data is compatible with the invariant. If the input data is not compatible with the invariant, the `RiskEngine` will not execute the invariant and will return an error.

### Addressing
All invariants have a boolean propety `Addressing` which determines if the invariant is addressable. To be addressable, an invariant must only execute under the context of a single address.

For example, a `balance_enforcement` invariant session will be addressable because it only executes invalidation logic for the native ETH balance of a single address. 

### Invariant States
State is used to represent the current state of an invariant. The state of an invariant is represented by a `InvariantState` type. The following states are supported:
- `Running` - The invariant is currently running and is being executed by the `RiskEngine`
- `Inactive` - The invariant is currently inactive and is not being executed by the `RiskEngine`
- `Paused` - The invariant is currently paused and is not being executed by the `RiskEngine`

### Execution Type
A risk engine has an associated execution type that defines how the risk engine will execute the invariant. There are two types of execution:
1. `Hardcoded` - The invariant invalidation logic is hardcoded directly into the risk engine registry using native Go code. These invariants can only be changed by modifying the application source code of the engine registry.
2. `Dynamic` - The invariant invalidation logic is dynamically loaded and executed by a risk engine. These invariants can be changed without modifying the application source code of the engine registry.
**As of now, this is not supported.**

## Hardcoded Invariant Types
As of now, there are two types of hardcoded invariants that a user can deploy active sessions for:
-  `invocation` - Invariant that is triggered when a specific smart contract function is invoked **Not currently supported**
- `balance` - Invariant that checks an address's balance changes and ensures that the balance does not exceed a certain threshold

### How to add a new invariant
1. Create a new file in the `internal/engine/registry` directory that stores the invariant implementaion. The implementation must adhere to the interface specified for the `BaseInvariant` type. 

3. Add a new entry to the `InvariantType` enum in `internal/core/constants.go`
2. Add a new entry to the registry in `internal/engine/registry/registry.go`

## Dynamic Invariant Types
**Not currently supported**
Dynamic invariants are programmable entities that can be deployed as arbitrary code by a user. They are represented via some code standard that is dynamically executable by a Risk Engine. Unlike `Hardcoded` invariants, dynamic invariants can be deployed and executed without modifying the source code of the Pessimism application.